객체지향 설계의 핵심

- 협력: 기능 구현을 귀한 객체들 사이의 상호작용
- 책임: 협력을 위해 객체가 수행하는 행동
- 역할: 대체 가능한 책임의 집합

> 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동

# 01 데이터 중심의 영화 예매 시스템

객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야 한다

상태에 초점을 맞추면

- 객체의 상태는 구현에 속함
- 구현은 불안정해 변하기 쉬움
- 변경에 취약한 설계

책임에 초점을 맞추면

- 책임은 인터페이스에 속함
- 객체는 인터페이스 뒤로 구현을 캡슐화 → 구현 변경 파장 방지
- 변경에 안정적인 설계

## 데이터를 준비하자

데이터 중심 설계에 매몰되었다는 신호

- ‘데이터가 무엇인가’로 시작해 객체 인스턴스 변수부터 결정
- 객체의 종류를 결정하는 값과 종류에 따라 배타적으로 사용되는 변수들이 한 클래스에 포함
- 변수가 private이고 getter로만 접근 가능하면 캡슐화 되어있는것일까?

## 영화를 예매하자

할인 가능 여부 확인 + 예매 요금 결정

- 할인 가능 여부를 지역 변수로 두고 할인 조건 유형에 따라 분기 나눠 처리
- 할인 정책에 따라 요금 계산 방식 분기 나눠 처리

# 02 설계 트레이드오프

객체지향 설계 품질 척도

- 캡술화
- 응집도
- 결합도

## 캡슐화

변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법

- 객체지향의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 숨기는 것

## 응집도와 결합도

응집도: 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는가

- 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정
    - 하나의 모듈만 변경, 모듈 전체가 함께 변경 → 응집도 높다
    - 다수 모듈 변경, 모듈 일부만 변경 → 응집도 낮다

결합도: 협력에 필요한 적절한 수준의 관계만을 유지하는가

- 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도
    - 하나의 모듈을 수정할 때 얼마나 많은 모듈이 함께 수정되는가

*인터페이스에 대해 프로그래밍하라*

# 03 데이터 중심의 영화 예매 시스템의 문제점

캡슐화 위반 → 높은 결합도, 낮은 응집도

- 캡슐화의 정도가 응집도와 결합도를 결정한다

## 캡슐화 위반

추측에 의한 설계 전략

- 협력 문맥을 고민하지 않고 추측 → 접근자와 수정자에 과도하게 의존
- 메서드에서 내부 상태 과도하게 드러나 캡슐화 원칙 위반

## 높은 결합도

- 내부구현이 인터페이스에 드러난다 = 내부 구현 변경되면 모든 클라이언트 함께 변경
- 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합

## 낮은 응집도

- 낮은 응집도 = 서로 다른 이유로 변경되는 코드가 하나의 모듈안에 공존
- 변경과 상관 없는 코드들이 영향 받게 됨
- 하나의 요구사항 변경 → 여러 모듈 수정

> SRP(Single Responsibility Principle): 모듈은 단 한가지의 변경 이유만 가져야 한다

# 04 자율적인 객체를 향해

## 캡슐화를 지켜라

- 메서드를 통해서만 상태에 접근하게 하라
    - 단순히 하나의 값 반환 X, 객체의 책임 수행
- 객체가 자기 스스로의 상태를 책임지게 하라
    - 상태 변경의 주체가 스스로가 되도록 책임 이동

## 스스로 자신의 데이터를 책임지는 객체

객체 설계할 때 두 개의 개별적인 질문을 분리해서 생각

- 이 객체가 어떤 데이터를 포함해야 하는가?
    - 어떤 데이터를 관리해야 하는가
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

→ 내부 상태 저장 방식 + 상태에 대해 호출 가능한 오퍼레이션의 집합 = 새로운 데이터 타입

# 05 하지만 여전히 부족하다

## 캡슐화 위반

- 메서드 시그니처를 통해 내부 정보 노출
- 메서드를 통해 구현 방법의 종류 가지 수 그대로 노출

*캡슐화는 변하는 어떤 것이라도 감추는 것*

## 높은 결합도

- 구현 방식이 추가되면 클라이언트 수정 필요
- 메서드 시그니처 변경되면 클라이언트 수정 필요

## 낮은 응집도

- 하나의 변경을 위해 노출된 구현에 의존하는 모든 모듈 변경 필요

# 06 데이터 중심 설계의 문제점

- 너부 이른 시기에 데이터에 관해 결정하도록 강요
- 협력 문맥 고려 없이 객체를 고립시킨 채 오퍼레이션 결정

## 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다

너무 이른 시기에 데이터에 대해 결정

- 데이터 관점에서 객체는 데이터의 집합체 → 데이터 사용 절차를 별도 객체에 구현 → 캡슐화 무너짐
- 데이터 먼저 결정한 후 오퍼레이션 결정 → 데이터에 관한 지식이 인터페이스로 노출 → 캡슐화 실패

## 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

객체의 외부가 아닌 내부에 초점

- 객체 구현부터 결정한 후 협력 고민 → 억지로 끼워맞춘 인터페이스
- 인터페이스에 구현 노출 → 협력이 구현 세부사항에 종속 → 내부 구현 변경이 협력하는 객체 모두에게 영향
