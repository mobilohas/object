애플리케이션 ≠ 클래스의 집합

클래스로 구성되지만 메시지로 정의된다

# 01 협력과 메시지

## 클라이언트-서버 모델

메시지 전송 객체 = 클라이언트, 수신 객체 = 서버

- 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용

객체가 독립적으로 수행할 수 있는 것 보다 더 큰 책임을 수행하려면 다른 객체와 협력해야 한다

## 메시지와 메시지 전송

메시지 = 객체들의 협력을 위한 의사소통 수단(오퍼레이션 + 인자)

- 메시지 전송: 한 객체가 다른 객체에게 도움을 요청하는 것 (메시지 + 메시지 수신자)
- 메시지 전송자: 메시지 전송 객체
- 메시지 수신자: 메시지 수신 객체

## 메시지와 메서드

메서드 = 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저

- 메시지를 전송했을 때 실제로 어떤 메서드가 실행될지는 실행 시점에 결정됨
- 메시지 전송자와 수신자가 느슨하게 결합

## 퍼블릭 인터페이스와 오퍼레이션

퍼블릭 인터페이스 = 객체가 외부에 공개하는 메시지의 집합

오퍼레이션 = 퍼블릭 인터페이스에 포함된 메시지

- 오퍼레이션은 추상, 메서드는 오퍼레이션에 대한 구현

## 시그니처

시그니처 = 오퍼레이션의 이름 + 파라미터 목록

# 02 인터페이스와 설계 품질

좋은 인터페이스 = 최소한의, 추상적인 인터페이스

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법들

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

## 디미터 법칙

협력 경로를 제한하라

- 낯선 자에게 말하지 말라, 인접한 이웃하고만 말하라, 하나의 도트만 사용하라

클래스의 내부에서 메시지를 전송할 수 있는 객체의 조건

- 메서드의 인자로 전달된 클래스
- 인스턴스 변수의 클래스

shy code(부끄럼타는 코드): 불필요한 것을 다른 객체에 보여주지 않고 다른 객체의 구현에 의존하지 않는 코드

- 디미터 법칙을 지키면 클라이언트, 서버 간 낮은 결합도 유지할 수 있다

train wreck(기차 충돌): 메시지 전송자가 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는 코드

- 메시지 수신자의 내부 정보를 자세히 드러냄 → 강한 결합

## 묻지 말고 시켜라

Tell, Don’t Ask: 객체의 상태에 관해 묻지 말고 원하는 것을 시켜라

- 상태를 묻는 오퍼레이션 → 행동을 요청하는 오퍼레이션으로 대체

## 의도를 드러내는 인터페이스

“어떻게” 수행하는지 나타나는 메서드 이름의 단점

- 메서드 내부 구현을 이해하지 못하면 클라이언트 입장에서 어떤 작업을 수행하는지 알기 어려움
- 메서드 수준에서 캡슐화 위반

의도를 드러내는 선택자: “무엇을” 하는지 드러내는 메서드

- 클라이언트 관점에서 어떤 작업인지 정의할 수 있음
- 매우 다른 두 번째 구현을 상상한 뒤 해당 메서드에 하나의 이름을 붙인다고 상상해보라

의도를 드러내는 인터페이스

- 타입 이름 + 메서드 이름 + 인자 이름이 모두 결합되어 형성
- 구현과 관련된 모든 정보 캡슐화하고 협력과 관련된 의도만 표현할 것

## 함께 모으기

### 디미터 법칙 위반

- 디미터 법칙 위반 = 내부 구현 노출 = 불안정 (인터페이스와 구현의 분리 원칙 위반)
- 클라이언트가 내부 구조를 묻게 하지 말고 직접 자신의 책임을 수행하도록 수정

### 묻지 말고 시켜라

- 디미터 법칙, 묻지 말고 시켜라 원칙에 따르면 자율적인 객체를 얻을 수 있다
- 구현이 인터페이스에 노출되지 않음 → 낮은 결합도
- 책임이 잘못된 곳에 할당될 가능성 낮음 → 높은 응집도

### 인터페이스에 의도를 드러내자

- 클라이언트가 메시지 전송을 통해 얻고 싶은 것이 무엇인가?
- 클라이언트가 원하는 것, 즉 클라이언트의 의도를 표현하라

# 03 원칙의 함정

설계는 트레이드오프의 산물

- 적절하게 트레이드오프 할 수 있는 능력 필요

원칙이 현 상황에 부적합하다면 과감하게 무시하라

## 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

stream 코드는 도트가 많으니 디미터 법칙을 위반?

→ 객체 내부에 대해 드러내지 않으므로 디미터 법칙 위반은 아님

## 결합도와 응집도의 충돌

객체에게 시키는 것이 항상 가능한 것은 아니다

- 묻지 말고 시켜라 스타일을 준수하는 퍼블릭 인터페이스를 얻기 위해 객체의 본질적인 책임에서 벗어나는 일을 하게 된다면 옳은 방법일까?
- 때로는 캡슐화 향상 보다 응집도를 높이고 결합도를 낮추는게 더 좋은 방법일 수 있다
- 객체라면 내부 구조를 숨겨야 하지만 자료 구조라면 내부 구조를 숨길 필요가 없다

소프트웨어 설계에 법칙이나 존재하지 않는다

- 몇 안되는 법칙 중 하나 “경우에 따라 다르다”

# 04 명령-쿼리 분리 원칙

루틴 = 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈

- 프로시저: 부수효과 발생, 값 반환 X ⇒ 명령
- 함수: 값 반환, 부수효과 발생 X ⇒ 쿼리

명령-쿼리 분리 원칙

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다

명령-쿼리 인터페이스: 명령-쿼리 분리 원칙에 따라 작성된 인터페이스

- 기계 메타포 - 객체의 인터페이스는 관찰 가능한 상태를 보기 위한 디스플레이와 상태 변경을 위한 버튼의 집합
- 쿼리 버튼 - 디스플레이에 상태 표시
    - 여러 번 눌러도 같은 상태
- 명령 버튼 - 상태 변경, 결과 제공 X
    - 명령 버튼 누른 후 쿼리 버튼 누르면 이전과 다른 상태

## 반복 일정의 명령과 쿼리 분리하기

명령-쿼리가 섞여 있으면 실행 결과를 예측하기 어려워진다

- 내부적인 부수효과 → 이해하기 어려움, 오용하기 쉬움, 버그 양산

명령-쿼리를 분리하면 예측하기 쉬워진다

- 반환 값 있는 메서드는 부수효과 걱정 없이 사용, 반환 값 없는 메서드는 주의해서 사용
- 예측 가능, 이해하기 쉬움, 디버깅 용이

## 명령-쿼리 분리와 참조 투명성

참조 투명성 = 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꾸어도 결과가 달라지지 않는 특성

- 불변성: 어떤 값이 변하지 않는 성질(=부수효과 발생하지 않는다)
- 모든 함수를 하나의 결괏값으로 대체 가능 → 계산 쉬움
- 식의 순서 변경해도 식의 결과는 달라지지 않음

객체지향 패러다임은 객체 상태 변경을 기반으로 한다 → 명령-쿼리 분리 원칙을 통해 가변성으로 인한 균열 줄일 수 있다

- 명령형 프로그래밍: 부수효과 기반
- 함수형 프로그래밍: 부수효과 없는 수학적 함수에 기반

## 책임에 초점을 맞춰라

메시지를 먼저 선택하고 객체를 선택하라

- 디미터 법칙: 수신할 객체를 알지 못한 상태에서 메시지 먼저 선택 → 객체 내부 구조 고민 X
- 묻지 말고 시켜라: 클라이언트 관점에서 메시지 선택 → 정보 묻지 않고 원하는 것을 표횬
- 의도를 드러내는 인터페이스: 메시지 먼저 선택 = 클라이언트 관점에서 정한다 = 클라이언트의 의도 드러난다
- 명령-쿼리 분리 원칙: 협력 문맥 안에서 인터페이스 고민 → 예측 가능한 협력을 위해 분리하게 될 것

계약에 의한 설계

- 협력을 위해 클라이언트와 서버가 준수해야 하는 제약을 코드 상에 명시적으로 표현하고 강제
